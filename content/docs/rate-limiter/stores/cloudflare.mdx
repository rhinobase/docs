---
title: Cloudflare
description: Rate limiting on Cloudflare Workers with hono-rate-limiter
---

`hono-rate-limiter` provides multiple options for rate limiting on Cloudflare Workers. Choose the approach that best fits your needs:

| Approach | Best For | Consistency | Cost |
|----------|----------|-------------|------|
| [Rate Limiting API](#workers-rate-limiting-api) | Simple, native rate limiting | High | Included |
| [Workers KV](#workers-kv-store) | Global distribution | Eventually consistent | KV pricing |
| [Durable Objects](#durable-objects-store) | Precise, transactional | Strong | DO pricing |

## Workers Rate Limiting API

Cloudflare's native Rate Limiting API is the simplest approach. It uses Cloudflare's built-in rate limiting infrastructure without requiring external stores.

### Configuration

First, add the rate limit binding to your `wrangler.toml`:

```toml
[[unsafe.bindings]]
name = "MY_RATE_LIMITER"
type = "ratelimit"
namespace_id = "1001"
simple = { limit = 100, period = 60 }
```

### Usage

Use the `rateLimiter` with the `binding` option instead of `store`:

```ts
import { Hono } from "hono";
import { rateLimiter } from "hono-rate-limiter";

type Env = {
  MY_RATE_LIMITER: RateLimit;
};

const app = new Hono<{ Bindings: Env }>();

app.use(
  rateLimiter<{ Bindings: Env }>({
    binding: (c) => c.env.MY_RATE_LIMITER,
    keyGenerator: (c) => c.req.header("cf-connecting-ip") ?? "",
  })
);

app.get("/", (c) => c.text("Hello!"));

export default app;
```

### How It Works

When you use the `binding` option, `hono-rate-limiter` switches to Cloudflare's native rate limiting:

- Rate limits are configured in `wrangler.toml`, not in code
- No `windowMs` or `limit` options needed (configured in binding)
- The rate limit check is performed at the edge
- Results are stored by `c.set("rateLimit", success)` as a boolean

### Configuration Options

```ts
rateLimiter({
  binding: (c) => c.env.MY_RATE_LIMITER, // Required: Rate limit binding
  keyGenerator: (c) => string,            // Required: Client identifier
  message: "Rate limit exceeded",         // Optional: Response message
  statusCode: 429,                        // Optional: HTTP status
  handler: (c, next, options) => {},      // Optional: Custom handler
  skip: (c) => boolean,                   // Optional: Skip logic
});
```

## Workers KV Store

Use Cloudflare KV for globally distributed rate limiting. KV provides eventual consistency, which is suitable for most rate limiting use cases.

### Configuration

Add a KV namespace binding to your `wrangler.toml`:

```toml
[[kv_namespaces]]
binding = "RATE_LIMIT_KV"
id = "your-namespace-id"
```

### Usage

```ts
import { Hono } from "hono";
import { rateLimiter } from "hono-rate-limiter";
import { WorkersKVStore } from "hono-rate-limiter/stores/cloudflare";

type Env = {
  RATE_LIMIT_KV: KVNamespace;
};

const app = new Hono<{ Bindings: Env }>();

app.use(
  rateLimiter<{ Bindings: Env }>({
    windowMs: 60 * 1000, // 1 minute
    limit: 100,
    keyGenerator: (c) => c.req.header("cf-connecting-ip") ?? "",
    store: new WorkersKVStore({ namespace: c.env.RATE_LIMIT_KV }),
  })
);

export default app;
```

### Dynamic Store Initialization

Since KV namespace is accessed via `c.env`, you need to initialize the store per-request:

```ts
app.use(async (c, next) => {
  const limiter = rateLimiter({
    windowMs: 60_000,
    limit: 100,
    keyGenerator: (c) => c.req.header("cf-connecting-ip") ?? "",
    store: new WorkersKVStore({
      namespace: c.env.RATE_LIMIT_KV,
      prefix: "rl:",
    }),
  });
  return limiter(c, next);
});
```

### Configuration Options

```ts
new WorkersKVStore({
  namespace: kvNamespace, // Required: KV namespace binding
  prefix: "hrl:",         // Optional: Key prefix (default: "hrl:")
});
```

<Callout type="warn" title="KV Expiration Limitation">
Cloudflare KV has a minimum expiration of 60 seconds. The store automatically adjusts expiration times to meet this requirement. This doesn't affect rate limiting behavior, which is controlled by `resetTime`.
</Callout>

## Durable Objects Store

Durable Objects provide strong consistency and are ideal when you need precise rate limiting with transactional guarantees.

### Configuration

First, create the Durable Object class by exporting it from your worker:

```ts
// Export the Durable Object class
export { DurableObjectRateLimiter } from "hono-rate-limiter/stores/cloudflare";
```

Add the Durable Object binding to your `wrangler.toml`:

```toml
[durable_objects]
bindings = [
  { name = "RATE_LIMITER", class_name = "DurableObjectRateLimiter" }
]

[[migrations]]
tag = "v1"
new_classes = ["DurableObjectRateLimiter"]
```

### Usage

```ts
import { Hono } from "hono";
import { rateLimiter } from "hono-rate-limiter";
import {
  DurableObjectStore,
  DurableObjectRateLimiter,
} from "hono-rate-limiter/stores/cloudflare";

// Re-export for Cloudflare to find the DO class
export { DurableObjectRateLimiter };

type Env = {
  RATE_LIMITER: DurableObjectNamespace<DurableObjectRateLimiter>;
};

const app = new Hono<{ Bindings: Env }>();

app.use(async (c, next) => {
  const limiter = rateLimiter({
    windowMs: 60_000,
    limit: 100,
    keyGenerator: (c) => c.req.header("cf-connecting-ip") ?? "",
    store: new DurableObjectStore({
      namespace: c.env.RATE_LIMITER,
    }),
  });
  return limiter(c, next);
});

export default app;
```

### Configuration Options

```ts
new DurableObjectStore({
  namespace: doNamespace, // Required: DO namespace binding
  prefix: "hrl:",         // Optional: Key prefix (default: "hrl:")
});
```

### How It Works

The `DurableObjectRateLimiter` class extends Cloudflare's `DurableObject`:

1. Each unique key maps to a Durable Object instance
2. Hit counts are stored in the DO's transactional storage
3. An alarm is set to reset the count when the window expires
4. Operations are strongly consistent within each DO

## Comparison

### Workers Rate Limiting API

**Pros:**
- Native Cloudflare integration
- No external dependencies
- Simple configuration
- Edge-optimized

**Cons:**
- Rate limits configured in `wrangler.toml`, not code
- Less flexibility in rate limit logic

### Workers KV

**Pros:**
- Globally distributed
- Low latency reads
- Simple setup

**Cons:**
- Eventually consistent (may briefly allow over-limit)
- 60-second minimum expiration

### Durable Objects

**Pros:**
- Strong consistency
- Transactional guarantees
- Automatic cleanup via alarms

**Cons:**
- Higher latency (single point of coordination)
- More complex setup
- Higher cost for high-traffic scenarios

## Complete Example

Here's a complete Cloudflare Worker using Durable Objects:

```ts
import { Hono } from "hono";
import { rateLimiter } from "hono-rate-limiter";
import {
  DurableObjectStore,
  DurableObjectRateLimiter,
} from "hono-rate-limiter/stores/cloudflare";

// Re-export for Cloudflare
export { DurableObjectRateLimiter };

type Env = {
  RATE_LIMITER: DurableObjectNamespace<DurableObjectRateLimiter>;
};

const app = new Hono<{ Bindings: Env }>();

// Rate limit middleware
app.use("/api/*", async (c, next) => {
  const limiter = rateLimiter({
    windowMs: 60 * 1000,
    limit: 100,
    keyGenerator: (c) => {
      // Use API key if available, fallback to IP
      return c.req.header("x-api-key") ?? c.req.header("cf-connecting-ip") ?? "";
    },
    store: new DurableObjectStore({
      namespace: c.env.RATE_LIMITER,
      prefix: "api:",
    }),
    message: { error: "Rate limit exceeded", retryAfter: "60s" },
  });
  return limiter(c, next);
});

app.get("/api/data", (c) => {
  return c.json({ message: "Hello from the API!" });
});

export default app;
```

With `wrangler.toml`:

```toml
name = "my-rate-limited-api"
main = "src/index.ts"
compatibility_date = "2024-01-01"

[durable_objects]
bindings = [
  { name = "RATE_LIMITER", class_name = "DurableObjectRateLimiter" }
]

[[migrations]]
tag = "v1"
new_classes = ["DurableObjectRateLimiter"]
```

